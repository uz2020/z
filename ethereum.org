* learn
** learning hub
** ethereum basics
*** smart contracts
*** wallets
*** security and scam prevention
*** web3
** ethereum protocol
*** energy consumption
*** upgrades
*** improvement proposals
*** history
*** whitepayer
*** glossary
*** governance
*** blockchain bridges
*** zero-knowledge proofs

* mastering ethereum

** smart contracts and solidity

gas, is an incredibly important consideration in smart contract programming.

gas is a resource constraining the maximum amount of computation that Ethereum will allow a transaction to consume. if the gas limit is exceeded during computation, the following series of events occurs:
1. an "out of gas" exception is thrown
2. the state of the contract prior to execution is restored
3. all ether used to pay for the gas is taken as a transaction fee

users are discouraged from calling functions that have a high gas cost. it is thus in the programmer's best interest to minimize the gas cost of a contract's functions. to this end, there are certain practices that are recommended when constructing smart contracts, so as to minimize the gas cost of a function call.

** oracles

oracles, which are systems that can provide external data sources to Ethereum smart contracts.

in the context of blockchains, an oracle is a system that can answer questions that are external to Ethereum.

ideally oracles are systems that are trustless, meaning that they do not need to be trusted because they operate on decentralized principles.

*** why oracles are needed

a key component of the Ethereum platform is the ethereum Virtual Machine, with its ability to execute programs and update state of Ethereum, constrained by consensus rules, on any node in the decentralized network.

in order to maintain consensus, EVM execution must be totally deterministic and based only on the shared context of the Ethereum state and signed transactions.

this has two particularly important consequences: the first is that there can be no intrinsic source of randomness for the EVM and smart contracts to work with; the second is that extrinsic data can only be introduced as the data payload of a transaction.

to understand the prohibition of a true random function in the EVM to provide randomness for smart contracts.
it could be that a different resulting state would be achieved every time that the smart contract is evaluated. as such, there would be no way for the network, with its multitude of nodes running independently around the world, to ever come to a decentralized consensus on what the resulting state should be.

note that psedorandom functions, such as cryptographically secure hash functions, are not enough for many applications. take a gambling game that simulates coin flips to resolve bet payouts, which needs to randomize heads or tails, a miner can gain an advantage by playing the game and only including their transactions in blocks for which they will win.

so how do we get around this problem? well, all nodes can agree on the contents of signed transactions, so extrinsic information, including sources of randomness, price information, weather forecasts, etc., can be introduced as the data part of transactions sent to the network. however, such data simply cannot be trusted, because it comes from unverifiable sources.
we use oracles to attempt to solve these problems.

*** oracle use cases and examples

oracles, ideally, provide a trustless way of getting extrinsic information, such as the results of football games, the price of gold, or truly random numbers, onto the Ethereum platform for smart contracts to use. they can also be used to relay data securely to DApp frontends directly.

oracles can therefore be thought of as a mechanism for bridging the gap between the off-chain world and smart contracts.

allowing smart contracts to enforce contractual relationships based on real-world events and data broadens their scope dramatically.

the data they provide generally takes the form of attestations, such as passports or records of achievement. attestations will become a big part of the success of blockchain platforms in the future, particularly in relation to the related issues of verifying identity or reputation.

*** oracle design patterns

all oracles provide a few key functions, by definition. these include the ability to
1. collect data from an off-chain source
2. transfer the data on-chain with a signed message
3. make the data available by putting it in a smart contract's storage

once the data is available in a smart contract's storage, it can be accessed by other smart contracts via message calls that invoke a "retrieve" function of the oracle's smart contract;

it can also be accessed by Ethereum nodes or network-enabled clients directly by "looking into" the oracle's storage.

the three main ways to set up an oracle can be categorized as request-response, publish-subscribe, and immediate-read.

starting with the simplest, immediate-read oracles are those that provide data that is only needed for an immediate decision. again, hashing the data (more carefully, in Merkle trees with salts) and only storing the root hash in the smart contract's storage would be an efficient way to organize such a service.
this type of oracle stores data once in its contract storage, whence any other smart contract can look it up using a request call to the oracle contract.
note that the data stored by the oracle is likely not to be the raw data that the oracle is serving, e.g., for efficiency or privacy reasons. however, storing the full details of the certificates would be excessive. instead, a hash of the certificate is sufficient.

the next setup is publish-subscribe, where an oracle that effectively provides a broadcast service for data that is expected to change is either polled by a smart contract on-chain, or watched by an off-chain daemon for updates. this category has a pattern similar to RSS feeds, WebSub, and the like, where the oracle is updated with new information and a flag signals that new data is available to those who consider themselves "subscribed". interested parties must either poll the oracle to check whether the latest information has changed, or listen for updates to oracle contracts and act when they occur. 
ethereum event logs make it particularly easy for applications to look out for oracle updates, and so this pattern can in some ways even be considered a "push" service.
however, if the polling is done from a smart contract, which might be necessary for some decentralized applications (e.g., where activation incentives are not possible), then significant gas expenditure may be incurred.

the request-response category is the most complicated: this is where the data space is too huge to be stored in a smart contract and users are expected to only need a small part of the overall dataset at a time.

*** decentralized oracles

while centralized data or computation oracles suffice for many applications, they represent single points of failure in the Ethereum network. a number of schemes have been proposed around the idea of decentralized oracles as a means of ensuring data availability and the creation of a network of individual data providers with an on-chain data aggregation system.

ChainLink has proposed a decentralized oracle network consisting of three key smart contracts - a reputation contract, an order-matching contract, and an aggregation contract - and an off-chain registry of data providers.

*** oracle client interfaces in solidity

a solidity example demonstrating how Oraclize can be used to continuously poll for the ETH/USD price from an API and store the result in a usable manner.

using Oraclize to update the ETH/USD exchange rate from an external source

to integrate with Oraclize, the contract EthUsdPriceTicker must be a child of usingOraclize

the usingOraclize contract is defined in the oraclizeAPI file. the data request is made using the oraclize_query function, which is inherited from the usingOraclize contract.

this is an overloaded function that expects at least two arguments:
1. the supported data source to use, such as URL, WolframAlpha, IPFS, or computation
2. the argument for the given data source, which may include the use of JSON or XML parsing helpers

in order to perform the query, Oraclize requires the payment of a small fee in ether, covering the gas cost for processing the result and transmitting it to the __callback function and an accompanying surcharge for the service. this amount is dependent on the data source and, where specified, the type of authenticity proof that is required. once the data has been retrieved, the __callback function is called by an Oraclize-controlled account permissioned to do the callback.

financial data provider also provides an oracle service for Ethereum, called BlockOne IQ, allowing market and reference data to be requested by smart contracts running on private or permissioned networks.


*** conclusions

as you can see, oracles provide a crucial service to smart contracts: they bring external facts to contract execution. with that, of course, oracles also introduce a significant risk - if they are trusted sources and can be compromised, they can result in compromised execution of the smart contracts they feed.

generally, when considering the use of an oracle be very careful about the trust model. if you assume the oracle can be trusted, you may be undermining the security of your smart contract by exposing it to potentially false inputs.

decentralized oracles can resolve some of these concerns and offer Ethereum smart contracts trustless external data. choose carefully and you can start exploring the bridge between Ethereum and the "real world" that oracles offer.
